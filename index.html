<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Who's That Pokémon?</title>
  <script>
      const basePath = location.pathname.replace(/[^/]+$/, '');

      const cssLink = document.createElement('link');
      cssLink.rel = 'stylesheet';
      cssLink.href = basePath + 'styles.css?ts=' + Date.now();

      document.head.appendChild(cssLink);
  </script>
</head>
<body>
  <h1>Who's That Pokémon?</h1>

  <div class="streaks">
    <div>Streak: <span id="streak">0</span></div>
    <div>Best: <span id="bestStreak">0</span></div>
  </div>

  <button id="settingsBtn" class="corner-info">Settings</button>

  <div id="settingsPanel" class="corner-panel">
    <h3>Settings</h3>

    <div class="checklist">
      <label>
        <input type="checkbox" id="includeForms" />
        Include Forms
      </label>

      <hr />

      <div id="genChecklist"></div>
    </div>

    <details>
      <summary>Excluded forms</summary>
      <ul>
        <li>Nidoran genders (only male, just write nidoran)</li>
        <li>Unown (only A, just write unown)</li>
        <li>Alolan Grimer (too similar)</li>
        <li>Hisuian Sneasel (too similar)</li>
        <li>Alolan Muk (too similar)</li>
        <li>Alolan Vulpix (too similar)</li>
        <li>Paldean Tauros (could add some forms)</li>
        <li>Anything added in Legends ZA (models not uploaded)</li>
        <li>Galarian Corsola (no model uploaded)</li>
      </ul>
    </details>
  </div>

  <div class="pokemon-container">
    <img id="pokemonImg" alt="Pokémon silhouette" />
    <div id="badge" class="badge">Correct!</div>
    <div id="pokemonName"></div>
  </div>

  <div style="display: flex; gap: 0.5em; align-items: center; margin-bottom: 1em;">
    <input id="guess" placeholder="Enter Pokémon name" />
    <button id="guessButton">Guess</button>
    <button id="nextButton">Skip</button>
  </div>

  <canvas id="confetti-canvas"></canvas>

  <script>
    /* ================= CONFIG ================= */
    const MAX_GEN = 3; // ONLY CHANGE THIS TO ADD GENS
    const PRELOAD_COUNT = 10;

    /* ================= STATE ================= */
    const pokemonByGen = {};
    const formsByGen = {};
    let pokemonList = [];
    let currentPokemon = "";
    let silhouetteIndex = 0;
    let streak = 0;
    let guessed = false;

    let bestStreak = localStorage.getItem("bestStreak")
      ? parseInt(localStorage.getItem("bestStreak"))
      : 0;

    const preloadedImages = {};
    const preloadQueue = [];

    /* ================= ELEMENTS ================= */
    const badgeEl = document.getElementById("badge");
    const pokemonImg = document.getElementById("pokemonImg");
    const pokemonNameEl = document.getElementById("pokemonName");
    const guessInput = document.getElementById("guess");
    const guessButton = document.getElementById("guessButton");
    const nextButton = document.getElementById("nextButton");

    /* ================= UI ================= */
    function renderGenCheckboxes() {
      const container = document.getElementById("genChecklist");

      for (let gen = 1; gen <= MAX_GEN; gen++) {
        const label = document.createElement("label");
        label.innerHTML = `
          <input type="checkbox" id="gen${gen}" checked />
          Gen ${gen}
        `;
        container.appendChild(label);
      }
    }

    /* ================= DATA LOADING ================= */
    async function loadPokemonList() {
      try {
        const promises = [];

        for (let gen = 1; gen <= MAX_GEN; gen++) {
          promises.push(
            fetch(`./public/gen${gen}_pokemon.txt`)
              .then(r => r.text())
              .then(t => {
                pokemonByGen[gen] = t.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
              })
          );

          promises.push(
            fetch(`./public/gen${gen}_forms.txt`)
              .then(r => r.text())
              .then(t => {
                formsByGen[gen] = t.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
              })
          );
        }

        await Promise.all(promises);

        document.getElementById("bestStreak").textContent = bestStreak;
        updatePokemonPool();
        updatePreloadQueue();
        displayNextPokemon();
      } catch (err) {
        console.error("Failed to load Pokémon lists", err);
      }
    }

    /* ================= POOL ================= */
    function updatePokemonPool() {
      const includeForms = document.getElementById("includeForms").checked;
      let pool = [];

      for (let gen = 1; gen <= MAX_GEN; gen++) {
        if (document.getElementById(`gen${gen}`).checked) {
          pool = pool.concat(pokemonByGen[gen] || []);
          if (includeForms) pool = pool.concat(formsByGen[gen] || []);
        }
      }

      pokemonList = pool;

      Object.keys(preloadedImages).forEach(k => delete preloadedImages[k]);
      preloadQueue.length = 0;
    }

    /* ================= PRELOADING ================= */
    function preloadPokemon(pokemon) {
      if (preloadedImages[pokemon]) return;

      const index = Math.floor(Math.random() * 4);
      const img = new Image();
      img.src = `./public/Pokemon_Renders/${pokemon}/${pokemon}_${index}.png?ts=${Date.now()}`;
      img.onload = () => preloadedImages[pokemon] = img;
    }

    function updatePreloadQueue() {
      while (preloadQueue.length < PRELOAD_COUNT && pokemonList.length) {
        const next = pokemonList[Math.floor(Math.random() * pokemonList.length)];
        if (!preloadQueue.includes(next)) {
          preloadQueue.push(next);
          preloadPokemon(next);
        }
      }
    }

    /* ================= GAME FLOW ================= */
    function displayNextPokemon() {
      if (!pokemonList.length) return;

      let next;
      do {
        next = preloadQueue.shift() || pokemonList[Math.floor(Math.random() * pokemonList.length)];
      } while (next === currentPokemon && pokemonList.length > 1);

      currentPokemon = next;
      updatePreloadQueue();

      silhouetteIndex = Math.floor(Math.random() * 4);
      pokemonImg.style.opacity = 0;
      pokemonImg.classList.remove("silhouette");

      const img = preloadedImages[currentPokemon] || new Image();
      if (!img.src) {
        img.src = `./public/Pokemon_Renders/${currentPokemon}/${currentPokemon}_${silhouetteIndex}.png?ts=${Date.now()}`;
      }

      const showImage = () => {
        pokemonImg.src = img.src;
        pokemonImg.classList.add("silhouette");
        pokemonImg.style.opacity = 1;
      };

      if (img.complete) {
        showImage();
      } else {
        img.onload = showImage;
      }

      badgeEl.style.opacity = 0;
      pokemonImg.classList.remove("shake");
      guessInput.value = "";
      guessInput.disabled = false;
      guessButton.disabled = false;
      nextButton.textContent = "Skip";
      pokemonNameEl.style.opacity = 0;
      guessed = false;
      guessInput.focus();
    }

    function checkGuess() {
      if (guessed) return;

      if (guessInput.value.trim().toLowerCase() === currentPokemon.toLowerCase()) {
        pokemonImg.classList.remove("silhouette");
        streak++;
        document.getElementById("streak").textContent = streak;

        if (streak > bestStreak) {
          bestStreak = streak;
          localStorage.setItem("bestStreak", bestStreak);
          document.getElementById("bestStreak").textContent = bestStreak;
        }

        badgeEl.style.opacity = 1;
        badgeEl.classList.remove("badge");
        void badgeEl.offsetWidth;
        badgeEl.classList.add("badge");

        launchConfetti();

        guessInput.disabled = true;
        guessButton.disabled = true;
        nextButton.textContent = "Next";
        guessed = true;
      } else {
        streak = 0;
        document.getElementById("streak").textContent = streak;
        pokemonImg.classList.remove("shake");
        void pokemonImg.offsetWidth;
        pokemonImg.classList.add("shake");
      }
    }

    /* ================= EVENTS ================= */
    nextButton.addEventListener("click", () => {
      if (!guessed && nextButton.textContent === "Skip") {
        pokemonImg.classList.remove("silhouette");
        pokemonNameEl.textContent = currentPokemon;
        pokemonNameEl.style.opacity = 1;
        guessInput.disabled = true;
        guessButton.disabled = true;
        nextButton.textContent = "Next";
        guessed = true;
      } else {
        displayNextPokemon();
      }
    });

    guessButton.addEventListener("click", checkGuess);
    guessInput.addEventListener("keydown", e => e.key === "Enter" && checkGuess());

    document.addEventListener("change", e => {
      if (e.target.id === "includeForms" || /^gen\d+$/.test(e.target.id)) {
        updatePokemonPool();
        updatePreloadQueue();
        displayNextPokemon();
      }
    });

    document.addEventListener("DOMContentLoaded", () => {
      renderGenCheckboxes();
      loadPokemonList();
      document.getElementById("settingsBtn")
        .addEventListener("click", () => {
          const panel = document.getElementById("settingsPanel");
          panel.style.display = panel.style.display === "block" ? "none" : "block";
        });
    });

    /* ================= CONFETTI ================= */
    const confettiCanvas = document.getElementById("confetti-canvas");
    const ctx = confettiCanvas.getContext("2d");
    let confettiParticles = [];

    function launchConfetti() {
      confettiCanvas.width = innerWidth;
      confettiCanvas.height = innerHeight;
      confettiParticles = Array.from({ length: 150 }, () => ({
        x: Math.random() * innerWidth,
        y: Math.random() * -innerHeight,
        r: Math.random() * 6 + 4,
        d: Math.random() * 30,
        tilt: Math.random() * 10 - 10,
        tiltAngleIncremental: Math.random() * 0.07 + 0.05,
        color: `hsl(${Math.random() * 360},100%,50%)`
      }));
      requestAnimationFrame(drawConfetti);
      setTimeout(() => confettiParticles = [], 1000);
    }

    function drawConfetti() {
      ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
      confettiParticles.forEach(p => {
        ctx.beginPath();
        ctx.lineWidth = p.r / 2;
        ctx.strokeStyle = p.color;
        ctx.moveTo(p.x + p.tilt + p.r / 4, p.y);
        ctx.lineTo(p.x + p.tilt, p.y + p.tilt + p.r / 4);
        ctx.stroke();
        p.tilt += p.tiltAngleIncremental;
        p.y += (Math.cos(p.d) + 3 + p.r / 2) / 2;
      });
      if (confettiParticles.length) requestAnimationFrame(drawConfetti);
    }

    window.addEventListener("resize", () => {
      confettiCanvas.width = innerWidth;
      confettiCanvas.height = innerHeight;
    });
  </script>
</body>
</html>
